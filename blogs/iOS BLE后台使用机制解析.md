# iOS BLE后台使用机制解析

自从上次写过一篇博客之后，又是几个月过去了，时不我待啊，感觉时间越来越不够用，是不是程序员都有这种感觉。好吧闲话少说，开始今天的主题。

之前做过iOS端的蓝牙智能锁App，对于iOS BLE框架比较熟悉，其中我们有一个业务场景：当用户带着手机回到家的门口，这个时候他可以触碰一下智能锁上的按钮，此时智能锁可以自动和iOS设备建立蓝牙连接，然后交互数据开锁。在这种业务场景下，要求iOS应用无论在在前台还是在后台持续可用，且连接速度要在用户可以接受的范围。

众所周知，iOS系统是出了名的各种限制，特别是应用想要在后台长时间停留，偷偷的干些小动作的话，苹果肯定会说：玩蛋去吧，去用你们的Android，支持得很好哦。所以在iOS 6以前不可能使用蓝牙实现这种业务场景。所幸，苹果就是注重用户体验，为了推广智能家居，他们的工程师自然也想到了这种使用场景，所以，在iOS 7加入了新的API可以支持后台持续使用的操作了，这个特性就叫做`BLE State Preservation and Restoration`，本文就详细分析及如何使用这种特性，并用源码实现。

## iOS BLE相关基本知识

`Bluetooth LE`是`Bluetooth 4.0`标准，最大的特点是低功耗，一颗纽扣电池可以供小型的嵌入式BLE芯片（比如CC2540）使用半年左右，所以围绕BLE智能硬件创业可以说是层出不穷，智能锁属于其中的一种。BLE把互相进行蓝牙数据交互的设备在在蓝牙协议栈的`GAP(General Attribute Profile)`层（还记得分层思想吗，和计算机网络的TCP/IP分层有异曲同工之妙）中分为以下几种角色：
- Central
- Peripheral
- Oberserver
- Broadcaster
其中，最重要的角色是前两个，他和后两个的区别是：后两个不需要建立数据连接就可以获得数据，比如开发一个蓝牙心率计或者蓝牙温度计，Broadcoaster角色的设备不停的广播出读数供Observer获取数据，而前两个需要建立蓝牙数据连接，在安全性、数据自定义及流量控制方面可以有更多的操作，可以认为后两者是前两者的不连接时候的简化版。Central角色的设备我们一般称为处于主模式（Master），主模式发扫描并主动建立连接，它可以和多个从模式蓝牙设备建立连接，读取从模式的数据。相反，Peripheral角色的设备我们一般称为处于从模式（Slave），从模式下的设备广播等待主模式的连接请求，它一次只能和一个主模式设备建立连接。`BLE State Preservation and Restoration`特性需要支持BLE的主从模式设备之间进行。更多的蓝牙BLE知识请参考官方的文档《iOS Core Bluetooth Programming Guide》。

## Preservation和Restoration

App想要完全的多任务后台目前在iOS上是不可能的，即使使用了BLE的Restoration特性依然如此。经过我的经验和实践证明，iOS系统在应用后台使用一段时间后，如果出现内存吃紧的情况下，会将调用应用的生命周期方法`applicationWillTerminate:`，然后应用就被杀死了。关键就是在被杀死后，如果有需要，在该特性支持下，系统会重新后台启动App，然后执行执行相关的业务逻辑代码后，又会睡眠。在应用被系统启动后，如果执行逻辑是我们需要深入探索和解析的地方。

我们以iOS从模式为例（在实际项目开发中，考虑到省电要求，我们一般会选择iOS作为从模式，广播比扫描省电，这样对于用户手机的耗电量不太大，用户才不反感开启蓝牙一直使用），使用新的接口创建`initWithDelegate:queue:options:`来创建`CBPeripheralManager`实例，参数`CBPeripheralManagerOptionRestoreIdentifierKey`注册在为统蓝牙服务的标识，以便在系统被杀死后，根据该标识唤醒对应的App。
## 引用
